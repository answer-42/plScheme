#!/usr/bin/perl
use feature qw/switch say/;
use List::MoreUtils qw/zip/;

use Data::Dumper;

$env = {
    '+' => sub { $_[0]+$_[1] },
    '-' => sub { $_[0]-$_[1] },
    '*' => sub { $_[0]*$_[1] },
    '/' => sub { $_[0]/$_[1] },
    '=' => sub { $_[0]==$_[1] },
    '<' => sub { $_[0]<$_[1] },
    '>' => sub { $_[0]>$_[1] },
    '<=' => sub { $_[0]<=$_[0] },
    '>=' => sub { $_[0]>=$_[1] },
    'car' => sub { $_[0] },
    'cdr' => sub { @_[1..@_-1] },
    OUTER => 0,
};

sub set {
    my ($env, $key, $val) = @_;
    (defined $$env{$key}
	? $$env{$key} : $$env{OUTER}{$key}) = $val
}

sub find {
    my ($key, $env) = @_;
    return $$env{$key} if defined $$env{$key};
    return 0 unless $$env{OUTER};
    return find($key, $$env{OUTER});
}

sub parse {
    eval join ' ', map {s/([^\[\]]+)/'$1'/;
			s/([^\[]+)/$1,/r} split /\s/, $_[0] =~ y/()/[]/r;
}

sub scm_eval {
    my ($in, $env) = @_;
    return find($in, $env) if find($in, $env);
    return $in if ref $in ne 'ARRAY';

    given ($$in[0]) {
	when ('lambda') { sub { scm_eval($$in[2], {zip(@{$$in[1]},@_), OUTER=>$env}) } }
	when ('define') { $$env{$$in[1]} = scm_eval($$in[2], $env) }
	when ('if') { scm_eval(scm_eval($$in[1], $env) ? $$in[2] : $$in[3], $env) }
	when ('set!') { set($env, $$in[1], scm_eval($$in[2], $env)) }
	when ('quote') { @$in[1..@$in-1] }
	when ('begin') { [map { scm_eval($_, $env) } @$in[1..@$in-1]]->[-1] }
	when ('apply') { 
	    @exp = map {scm_eval($_, $env)} @$in[1..@$in-1];
	    $exp[0]->(@exp[1..@exp-1])
	}
	when ('call/cc') { ... }
	default {
	    @exp = map {scm_eval($_, $env)} @$in;
	    $exp[0]->(@exp[1..$#exp])
	}
    }
}

### Testing
use Test::More 'no_plan';

sub pe {
    scm_eval parse($_[0]), $env
}

subtest 'Operators' => sub {
    is( pe("(- 4 5)"), '-1');
    is( pe("(* 5 5)"), '25' );
};

subtest 'Stuff' => sub {
    is( pe("(if (< 1  2) 3 4)"), '3');
    pe("(define x 0)");
    is( pe("(begin (set! x 5) (+ x 1))"), '6');
    is(pe("(set! x 9) x"), '9');
};

subtest 'Define functions' => sub {
    pe("(define fact (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))");
    pe("(define fib (lambda (n) (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2))))))");

    is( pe("(fact 3)"), '6', 'factorial 3');
    is( pe("(fib 1)"), '1', 'fibonacci 1');
    is( pe("(fib 3)"), '2', 'fibonacci 3');
    is( pe("(fib 10)"), '55', 'fibonacci 10');
};

subtest 'Operators 2' => sub {
  TODO: {
	local $TODO = 'Not yet implemented.';
	is(pe('(apply + (quote 1 2))'), '3','apply');
	is(pe('(car (quote 1 2 3 4))'),'1','car');
	is(pe('(apply + (cdr (quote 1 2 3)))'), '5', 'apply-cdr');
	is(pe('(length (quote 1 2 3 4))'), '4', 'length');

	ok( print pe('(append (quote 1 2) (quote 3 4))') eq '1234', 'append');
	ok( print pe('(cdr (quote 1 2 3 4))') eq '234', 'cdr');

    }
};
